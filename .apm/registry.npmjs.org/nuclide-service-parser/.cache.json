{"_id":"nuclide-service-parser","_rev":"3-0045f02014c57fdc397a5e3c78099dd9","name":"nuclide-service-parser","description":"Provides support for developing services between Nuclide server and client","dist-tags":{"latest":"0.0.32"},"versions":{"0.0.0":{"bin":{"validate":"bin/validate"},"dependencies":{"babel-core":"5.8.21","nuclide-node-transpiler":"0.0.0","rx":"3.1.1"},"description":"Provides support for developing services between Nuclide server and client","devDependencies":{"nuclide-external-interfaces":"0.0.0","nuclide-jasmine":"0.0.0","nuclide-node-transpiler":"0.0.0","nuclide-test-helpers":"0.0.0"},"main":"./lib/main","name":"nuclide-service-parser","nuclide":{"packageType":"Node","testRunner":"npm"},"repository":{"type":"git","url":"git+https://github.com/facebook/nuclide.git"},"scripts":{"test":"node --harmony node_modules/.bin/jasmine-node-transpiled spec"},"version":"0.0.0","bugs":{"url":"https://github.com/facebook/nuclide/issues"},"homepage":"https://github.com/facebook/nuclide#readme","_id":"nuclide-service-parser@0.0.0","_shasum":"b2e2586cc3617009a2342158c3f86ea947a90fed","_from":".","_npmVersion":"2.11.2","_nodeVersion":"0.12.5","_npmUser":{"name":"fb","email":"opensource+npm@fb.com"},"dist":{"shasum":"b2e2586cc3617009a2342158c3f86ea947a90fed","tarball":"http://registry.npmjs.org/nuclide-service-parser/-/nuclide-service-parser-0.0.0.tgz"},"maintainers":[{"name":"fb","email":"opensource+npm@fb.com"}],"directories":{}},"0.0.31":{"bin":{"validate":"bin/validate"},"dependencies":{"babel-core":"5.8.21","nuclide-node-transpiler":"0.0.31","rx":"3.1.1"},"description":"Provides support for developing services between Nuclide server and client","devDependencies":{"nuclide-external-interfaces":"0.0.31","nuclide-jasmine":"0.0.31","nuclide-node-transpiler":"0.0.31","nuclide-test-helpers":"0.0.31"},"license":"SEE LICENSE IN LICENSE","main":"./lib/main","name":"nuclide-service-parser","nuclide":{"packageType":"Node","testRunner":"npm"},"repository":{"type":"git","url":"https://github.com/facebook/nuclide"},"scripts":{"test":"node --harmony node_modules/.bin/jasmine-node-transpiled spec"},"version":"0.0.31","bugs":{"url":"https://github.com/facebook/nuclide/issues"},"homepage":"https://github.com/facebook/nuclide","_id":"nuclide-service-parser@0.0.31","_shasum":"6cd93831d16ef1d59c10ead3f5b3d0f17c3ec4a8","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"fb","email":"opensource+npm@fb.com"},"dist":{"shasum":"6cd93831d16ef1d59c10ead3f5b3d0f17c3ec4a8","tarball":"http://registry.npmjs.org/nuclide-service-parser/-/nuclide-service-parser-0.0.31.tgz"},"maintainers":[{"name":"fb","email":"opensource+npm@fb.com"}],"directories":{}},"0.0.32":{"bin":{"validate":"bin/validate"},"dependencies":{"babel-core":"5.8.21","nuclide-node-transpiler":"0.0.32","rx":"3.1.1"},"description":"Provides support for developing services between Nuclide server and client","devDependencies":{"nuclide-external-interfaces":"0.0.32","nuclide-jasmine":"0.0.32","nuclide-node-transpiler":"0.0.32","nuclide-test-helpers":"0.0.32"},"license":"SEE LICENSE IN LICENSE","main":"./lib/main","name":"nuclide-service-parser","nuclide":{"packageType":"Node","testRunner":"npm"},"repository":{"type":"git","url":"https://github.com/facebook/nuclide"},"scripts":{"test":"node --harmony node_modules/.bin/jasmine-node-transpiled spec"},"version":"0.0.32","bugs":{"url":"https://github.com/facebook/nuclide/issues"},"homepage":"https://github.com/facebook/nuclide","_id":"nuclide-service-parser@0.0.32","_shasum":"9e42d7d250a46a3cfbd0c65139fe8b23f346ad54","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"fb","email":"opensource+npm@fb.com"},"dist":{"shasum":"9e42d7d250a46a3cfbd0c65139fe8b23f346ad54","tarball":"http://registry.npmjs.org/nuclide-service-parser/-/nuclide-service-parser-0.0.32.tgz"},"maintainers":[{"name":"fb","email":"opensource+npm@fb.com"}],"directories":{}}},"readme":"# Nuclide Service Parser\n\nThis package is the core of the Nuclide Service Framework, implementing the following components:\n\n**Definition File Parsing** - The function `parseServiceDefinition`, exported from `lib/service-parser.js` takes in the string source of a service definition file, and returns an object of type `Definitions`, which describes all of the functions, classes, and type aliases encoded in the file.\n\n**Remote Proxy Generation** - The function `generateProxy`, exported from `lib/proxy-generator.js` takes in the previously generated `Definitions` object, and constructs a remote proxy factory function, which can then be used to construct a proxy module for any given host.\n\n**The TypeRegistry class** - This class handles marshalling and unmarshalling messages based off of type annotations, and exports the `marshal` and `unmarshal` functions. These functions both take the value to be transformed as the first parameter, and the type description itself as the second parameter.\n\n- [Type Abstraction](#type-abstraction)\n  - [Valid Types](#valid-types)\n  - [Invalid Types](#invalid-types)\n  - [Remote Objects](#remote-objects)\n  - [Return Types](#return-types)\n    - [`Void`](#void)\n    - [`Promise<A>`](#promisea)\n    - [`Observable<A>`](#observablea)\n- [Proxy Generation](#proxy-generation)\n- [Marshalling / Unmarshalling System](#marshalling--unmarshalling-system)\n\n## Type Abstraction\n\nThe service framework uses a simplified type abstraction that covers a subset of the features of Flow. It consists of a large tagged union, which can be seen in the [types.js](./types.js) file. Parameterized types like `Map`, `Set`, and Object type annotations carry their parameters as data, so that they can be serialized and deserialized properly.\n\n### Valid Types\n\nThe following types should serialize properly.\n- Primitives\n  - `string`\n  - `number`\n  - `boolean`\n- NuclideUri\n- Nullable Types, written as `?T`\n- Collections\n  - `Array<T>`\n  - `Set<T>`\n  - `Map<K, V>`\n  - Object Types, written in the form `{ field: T; ... }`\n    - Keys can be optional, which is distinct from a required key that points to a nullable value.\n- Date\n- Buffer\n- RegExp\n- Any Type Alias defined in the set of currently loaded service definitions.\n  - Defined using the syntax `export type TypeAlias = ...;`\n- Any Remote object type.\n  - Defined using the syntax `export class RemoteClass {...}`\n\n### Invalid Types\nThe types listed below are not supported.\n\n- Union Types - I don't think it's possible to distinguish between all of the types in a reliable way. Instead, a Union can be represented in Protobuf-like fashion, with a wrapper class that has nullable components.\n  ```js\n  export type UnionType = {\n    a: ?PossibleTypeA;\n    b: ?PossibleTypeB;\n    c: ?PossibleTypeC;\n  };\n  ```\n- Callbacks - However, it should be possible to implement this using the `FunctionType` object.\n\n### Remote Objects\nRemote objects are pass-by-reference. When they are returned from the server, the RPC framework returns a unique ID for the object. On the client side, this is wrapped inside of a proxy object, where methods can be dispatched as if the object was present locally.\n\n### Return Types\nFunctions or methods can return one of three things.\n\n#### `Void`\nMethods that return `void` are fire-and-forget. They have no concept of completion, and the client is never returned a result.\n\n#### `Promise<A>`\nMethods can return a `Promise<A>`, where `A` is any valid type. Additionally, `Promise<void>` is supported, in cases where the method does not return a result, but a client might still want to wait for it's completion.\n\n#### `Observable<A>`\nMethods can return an `Observable<A>`, where `A` is any valid type. This should be used in order to stream the results of a query.\n\n## Proxy Generation\n\nThe `generateProxy` function does not return a proxy directly, but rather returns a function that can be used to construct proxies. This is because we need a separate proxy for each remote host. Thus, the factory function takes in a client object and closes over it, returning a module that implements the correct API.\n\nThe client object must implement the following functions:\n\n- `callRemoteFunction` - Used to call a module-level function, or a static method of a class.\n- `createRemoteObject` - Create an instance of a remote object, using the constructor arguments. Returns a numerical id that represents the remote object.\n- `callRemoteMethod` - Call a method of a remote object.\n- `disposeRemoteObject` - Destroy the id => object mapping of a remote object, and call it's dispose method.\n- `marshal` and `unmarshal` - Serialize and deserialize a type, respectively. Likely, the client will implement these functions by delegating to a `TypeRegistry` object.\n\n## Marshalling / Unmarshalling System\nThe service framework needs to automatically marshal and unmarshal a wide variety of objects, simply by looking at the type annotations of a function. This is accomplished by assigning every type a marshalling and unmarshalling function, keyed in a Map by the name of the type. The TypeRegistry class encapsulates these two maps, along with functions for marshalling a wide variety of types.\n\n***Marshallers can reference other marshallers.*** This is what makes it possible to have parameterized types like `Array<T>`, or object types of the form `{ field: T; ... }`. The marshallers registered under `object` or `array` simple redirect conversions to the appropriate marshaller for the type of their elements.\n\n***Marshallers are asynchronous.*** Thus, they should return a Promise that resolves to the serialized value. This is primarily to cover special cases, and most marshallers can simply `return Promise.resolve(value)`. `async` functions are also a good pattern for creating marshallers.\n\nNote that a type can actually have four total transformation functions - a marshaller and unmarshaller on the client, and a marshaller and unmarshaller on the server. This is to account for cases where the server and client are not symmetrical. See the table below for why four separate functions are required in the case of serializing remote objects.\n\n| Location | Marshaller | Unmarshaller |\n|----------|---------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|\n| Server | Return the Object's ID as a string. If the Object doesn't have an ID, generate one and put it into a map that keys from ID => Object. | Lookup the string ID in the global registry and return the Object. |\n| Client | Extract the ID of the Proxy Object, and send it as a string. | Return the Proxy object associated from the string ID. If no proxy exists, create one and bake in the ID. |\n\nDue to the fact that these types, such as NuclideUri, require more information than what is known in the TypeRegistry object, their marshallers are registered in the `ServerComponent` and `ClientComponent` classes\n","maintainers":[{"name":"fb","email":"opensource+npm@fb.com"}],"time":{"modified":"2015-09-15T17:29:00.376Z","created":"2015-08-31T15:05:27.573Z","0.0.0":"2015-08-31T15:05:27.573Z","0.0.31":"2015-09-15T00:32:27.860Z","0.0.32":"2015-09-15T17:29:00.376Z"},"homepage":"https://github.com/facebook/nuclide","repository":{"type":"git","url":"https://github.com/facebook/nuclide"},"bugs":{"url":"https://github.com/facebook/nuclide/issues"},"readmeFilename":"README.md","license":"SEE LICENSE IN LICENSE","_attachments":{},"_etag":"\"B3ENTN3X1AYZ2UW1F3803QMEO\""}